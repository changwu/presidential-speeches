#!/usr/bin/env python3

"""fetch-videos: TBD
First, let's convert a bunch of named files in data to URLs.
"""

import sys
import os
import re
import getopt
import shutil
import urllib.request
import collections

MILLER_CENTER_BASE_URL = "https://millercenter.org/the-presidency/presidential-speeches/"
HTML_DIR = "html"
VIDEO_DIR = "videos"

def date_convert_path(basename):
    """Convert, e.g., "2013-01-21-second-inaugural-address.txt"
    to its Miller Center name: "january-21-2013-second-inaugural-address".
    """
    year = basename[0:4]
    month = basename[5:7]
    day = str(int(basename[8:10])) # cheaply remove any leading 0
    rest = basename[11:]
    # The "right" way to do this would be to import the calendar
    # module and use calendar.month_name[N].  Unfortunately, that
    # returns the month name in the current locale (I guess meaning
    # the locale at the time the module was imported), and I at least
    # don't know a reliable way to override that to en_US locale.
    # You might be running this code anywhere in any language, but the
    # Miller Center is in the U.S. and using American English, so we
    # hardcode the month names here, 1-indexed instead of 0-indexed.
    month_names = ["אַדר ג", "january", "february", "march", "april",
                   "may", "june", "july", "august", "september",
                   "october", "november", "december",]
    return f"{month_names[int(month)].lower()}-{day}-{year}-{rest}"


def main():
    speeches = None
    try:
        (opts, args) = getopt.getopt(sys.argv[1:], "i:h?",
                                     [ "input=",
                                       "help", 
                                       "usage",
                                     ])
    except getopt.GetoptError as err:
        sys.stderr.write(str(err))
        sys.stderr.write("\n")
        sys.exit(1)

    for opt, optarg in opts:
        if opt in ("-h", "-?", "--help", "--usage",):
            print(__doc__)
            sys.exit(0)
        elif opt in ("-i", "--input",):
            with open(optarg) as f:
                speeches = [line.rstrip() for line in f]

    if speeches is None:
        sys.stderr.write("ERROR: No file containing a list of speeches given.\n")
        sys.stderr.write("       You probably forgot to use -i / --input.\n")
        sys.exit(1)
        
    # Fetch the HTML page for each speech.
    for line in speeches:
        basename, ign = os.path.splitext(os.path.basename(line))
        url_path = date_convert_path(basename)
        html_file_path = os.path.join(HTML_DIR, url_path) + ".html"
        full_url = MILLER_CENTER_BASE_URL + url_path
        if not os.path.exists(html_file_path):
            print(f"Fetching {html_file_path}... ", end="")
            with urllib.request.urlopen(full_url) as response:
                with open(html_file_path, "wb") as html_file:
                    shutil.copyfileobj(response, html_file)
            print("done.")
        else:
            print(f"Already present: '{html_file_path}'.")

    print("")
    # Get the URL for each speech's video.  Re-read the names of the
    # HTML files locally, so that in case there were any problems
    # earlier they don't hold us up in this step.
    html_basenames = [f for f in os.listdir(HTML_DIR) if f.endswith(".html")]
    # The HTML actually has several places where the video file is
    # mentioned.  For example:
    # 
    #   [...]
    #   <video  poster=https://millercenter.org/sites/default/files/styles/video_poster_16x9_desktop_2x/public/mc-logo-video-poster.jpg?itok=Fbo2e12e controls>
    #      <source type="" src="https://player.vimeo.com/external/215702311.hd.mp4?s=0fb4ba0486df869453d6f80daf5fb484e7a041b1&amp;profile_id=174">
    #   </video>
    #   <div class="poster-frame">
    #   <div class="article--teaser-image-field">  <img loading="lazy" src="/sites/default/files/styles/video_poster_16x9_desktop_2x/public/mc-logo-video-poster.jpg?itok=Fbo2e12e" width="1600" height="900" alt="Miller Center logo" />
    #   </div>
    #     <a href="https://player.vimeo.com/external/215702311.hd.mp4?s=0fb4ba0486df869453d6f80daf5fb484e7a041b1&amp;profile_id=174" class="video-trigger">Play Video</a>
    #   </div>
    #   [...]
    # 
    # Looks straightforward, right?
    #
    # Nah, you knew it wouldn't be that easy :-)
    # 
    # Sometimes the video is on Vimeo, sometimes on Cloudfront,
    # sometimes on Amazon S3, and who knows what other services
    # they're using -- those are just the three I noticed tonight.
    # 
    # Luckily, the "<source ...>" tag is always all on one line, and
    # al the videos seem to end with ".mp4".  So we don't have to use
    # BeautifulSoup or whatever to actually parse the HTML (which in a
    # way is a pity, because BeautifulSoup is fun to use).  Instead,
    # we can get away with reading the file line by line and doing a
    # regexp match on each line.
    # 
    # For each file, we find all the places where a video is linked to
    # (it seems to be four places per file) and compare them.  If
    # they're not all the same, then we issue a warning.
    video_re = re.compile('.*<(source|a)\s+.*(src|href)="(https://.*\.mp4).*')
    for name in html_basenames:
        video_urls = collections.defaultdict(int) # standard dict of counts
        html_file = os.path.join(HTML_DIR, name)
        with open(html_file, "r") as f:
            while line := f.readline():
                m = video_re.match(line)
                if m is not None:
                    video_url = m.group(3)
                    video_urls[video_url] += 1
        if len(video_urls) == 0:
            sys.stderr.write(f"WARNING: No video URLs found in '{html_file}'\n")
        elif len(video_urls) > 1:
            sys.stderr.write(f"WARNING: More than one video URL found in '{html_file}':\n")
            for video_url, count in video_urls:
                sys.stderr.write(f"         '{video_url}' ({count} times):\n")
        else:
            video_url, = video_urls.keys()
            print(f"{html_file}: '{video_url}'")


if __name__ == '__main__':
  main()
