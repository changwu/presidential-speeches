#!/usr/bin/env python3

"""fetch-videos: TBD
First, let's convert a bunch of named files in data to URLs.
"""

import sys
import os
import re
import getopt
import shutil
import urllib.request
import collections
import time
import random

MILLER_CENTER_BASE_URL = "https://millercenter.org/the-presidency/presidential-speeches/"
HTML_DIR = "html"
VIDEO_DIR = "videos"
# These next two directories help us track what upstream web page and
# video names correspond to what local names in HTML_DIR and VIDEO_DIR.
# 
# The way the Miller Center does naming, each speech's web page has a
# url path like "february-28-2017-address-joint-session-congress", and
# then the HTML in that web page has links to the video for the speech
# -- but the video names are all over the place; there is no naming
# convention for them at all.
# 
# We, meanwhile, would like to have predictable names locally, using
# the same style of filenames (i.e., starting with an ISO 8601 date)
# as the transcripts do in ../data/.  So that's how things are
# arranged in HTML_DIR and VIDEO_DIR.  Then in UPSTREAM_HTML_DIR and
# UPSTREAM_VIDEO_DIR, we make symlinks linking the upstream name to
# the local name, so that if we ever need to map back and forth
# locally we can.
UPSTREAM_HTML_DIR = os.path.join("upstream-names", "html")
UPSTREAM_VIDEO_DIR = os.path.join("upstream-names", "videos")

def millerize(basename):
    """Convert, e.g., "2013-01-21-second-inaugural-address.txt"
    to its Miller Center name: "january-21-2013-second-inaugural-address".
    """
    year = basename[0:4]
    month = basename[5:7]
    day = str(int(basename[8:10])) # cheaply remove any leading 0
    rest = basename[11:]
    # The "right" way to do this would be to import the calendar
    # module and use calendar.month_name[N].  Unfortunately, that
    # returns the month name in the current locale (I guess meaning
    # the locale at the time the module was imported), and I at least
    # don't know a reliable way to override that to en_US locale.
    # You might be running this code anywhere in any language, but the
    # Miller Center is in the U.S. and using American English, so we
    # hardcode the month names here, 1-indexed instead of 0-indexed.
    month_names = ["אַדר ג", "january", "february", "march", "april",
                   "may", "june", "july", "august", "september",
                   "october", "november", "december",]
    return f"{month_names[int(month)].lower()}-{day}-{year}-{rest}"


def main():
    speeches = None
    try:
        (opts, args) = getopt.getopt(sys.argv[1:], "i:h?",
                                     [ "input=",
                                       "help", 
                                       "usage",
                                     ])
    except getopt.GetoptError as err:
        sys.stderr.write(str(err))
        sys.stderr.write("\n")
        sys.exit(1)

    for opt, optarg in opts:
        if opt in ("-h", "-?", "--help", "--usage",):
            print(__doc__)
            sys.exit(0)
        elif opt in ("-i", "--input",):
            with open(optarg) as f:
                speeches = [line.rstrip() for line in f]

    if speeches is None:
        sys.stderr.write("ERROR: No file containing a list of speeches given.\n")
        sys.stderr.write("       You probably forgot to use -i / --input.\n")
        sys.exit(1)
        
    # Fetch the HTML page for each speech.
    for speech in speeches:
        basename, ign = os.path.splitext(os.path.basename(speech))
        url_path = millerize(basename)
        full_url = MILLER_CENTER_BASE_URL + url_path
        our_html_file_path = os.path.join(HTML_DIR, basename) + ".html"
        upstream_html_file_path = os.path.join(UPSTREAM_HTML_DIR, url_path) + ".html"
        if not os.path.exists(our_html_file_path):
            print(f"Fetching {our_html_file_path}... ", end="")
            with urllib.request.urlopen(full_url) as response:
                with open(our_html_file_path, "wb") as html_file:
                    shutil.copyfileobj(response, html_file)
            print("done.")
            # This is kind of a kluge.  We just happen to "know" the
            # relative locations of HTML_DIR vs UPSTREAM_HTML_DIR,
            # so we insert the "../../" here.  We also assume that in
            # practice os.path.join() will be fine if its last
            # argument already includes a "/", which it will be.
            os.symlink(os.path.join("..", "..", our_html_file_path),
                       upstream_html_file_path)
        else:
            print(f"HTML file already present: '{our_html_file_path}'.")

    print("")

    # The HTML actually has several places where the video file is
    # mentioned.  For example:
    # 
    #   [...]
    #   <video  poster=https://millercenter.org/sites/default/files/styles/video_poster_16x9_desktop_2x/public/mc-logo-video-poster.jpg?itok=Fbo2e12e controls>
    #      <source type="" src="https://player.vimeo.com/external/215702311.hd.mp4?s=0fb4ba0486df869453d6f80daf5fb484e7a041b1&amp;profile_id=174">
    #   </video>
    #   <div class="poster-frame">
    #   <div class="article--teaser-image-field">  <img loading="lazy" src="/sites/default/files/styles/video_poster_16x9_desktop_2x/public/mc-logo-video-poster.jpg?itok=Fbo2e12e" width="1600" height="900" alt="Miller Center logo" />
    #   </div>
    #     <a href="https://player.vimeo.com/external/215702311.hd.mp4?s=0fb4ba0486df869453d6f80daf5fb484e7a041b1&amp;profile_id=174" class="video-trigger">Play Video</a>
    #   </div>
    #   [...]
    # 
    # Looks straightforward, right?
    #
    # Nah, you knew it wouldn't be that easy :-)
    # 
    # Sometimes the video is on Vimeo, sometimes on Cloudfront,
    # sometimes on Amazon S3, and who knows what other services
    # they're using -- those are just the three I noticed tonight.
    # 
    # Luckily, the "<source ...>" tag is always all on one line, and
    # al the videos seem to end with ".mp4".  So we don't have to use
    # BeautifulSoup or whatever to actually parse the HTML (which in a
    # way is a pity, because BeautifulSoup is fun to use).  Instead,
    # we can get away with reading the file line by line and doing a
    # regexp match on each line.
    # 
    # For each file, we find all the places where a video is linked to
    # (it seems to be four places per file) and compare them.  If
    # they're not all the same, then we issue a warning.
    video_re = re.compile('.*<(source|a)\s+.*(src|href)="(https://.*\.mp4[^"]*)".*')
    for speech in speeches:
        basename, ign = os.path.splitext(os.path.basename(speech))
        html_file = os.path.join(HTML_DIR, basename) + ".html"
        video_urls = collections.defaultdict(int) # standard dict of counts
        with open(html_file, "r") as f:
            while line := f.readline():
                m = video_re.match(line)
                if m is not None:
                    video_url = m.group(3)
                    video_urls[video_url] += 1
        if len(video_urls) == 0:
            sys.stderr.write(f"WARNING: No video URLs found in '{html_file}'\n")
        elif len(video_urls) > 1:
            # Probably a false alarm.  Often we'll see things like...
            # 
            #   https://player.vimeo.com/external/215702311.hd.mp4?s=0fb4ba0486df869453d6f80daf5fb484e7a041b1&amp;profile_id=174
            # 
            # and
            # 
            #   https://player.vimeo.com/external/215702311.hd.mp4?s=0fb4ba0486df869453d6f80daf5fb484e7a041b1&amp;profile_id=174?download=1
            # 
            # ...with the former appearing, say, 3 times in the file
            # and the latter appearing usually only once.
            # 
            # To check for this, we cut off the URLs at the "?" and
            # see if everything before that is the same.  If it is,
            # there's nothing to warn about; if not, we warn but still
            # continue.  Either way, we'll take the "best" unabridged
            # URL available, as explained later on.
            abridged_video_urls = collections.defaultdict(int)
            for video_url in video_urls:
                idx = video_url.find("?")
                if idx == -1:
                    abridged = video_url
                else:
                    abridged = video_url[:idx]
                abridged_video_urls[abridged] += 1
            if len(abridged_video_urls) > 1:
                sys.stderr.write(f"WARNING: More than one video URL found in '{html_file}':\n")
        # Take the "best" video URL.  The best one is the one
        # ending with "download=1" if such is available (and we
        # assume that there is only one of those, if any);
        # otherwise it's the one that appeared the most times in
        # the page.
        best_count = 0
        video_url = None
        for vu in video_urls:
            if vu.endswith("?download=1"):
                video_url = vu
                break
            else:
                if video_urls[vu] > best_count:
                    best_count = video_urls[vu]
                    video_url = vu
        print(f"{html_file}:")
        print(f"   {video_url}")
        tmp_basename = os.path.basename(video_url)
        idx = tmp_basename.find("?")
        if idx == -1:
            video_basename = tmp_basename
        else:
            video_basename = tmp_basename[:idx]
        our_video_file_path = os.path.join(VIDEO_DIR, basename) + ".mp4"
        print(f"   {our_video_file_path}")
        upstream_video_file_path = os.path.join(UPSTREAM_VIDEO_DIR, video_basename)
        print(f"   {upstream_video_file_path}")
#        if not os.path.exists(our_video_file_path):
#            print(f"Fetching {our_video_file_path}... ", end="")
#            with urllib.request.urlopen(video_url) as response:
#                with open(our_video_file_path, "wb") as video_file:
#                    shutil.copyfileobj(response, video_file)
#            print("done.")
#            # Earlier comment about kluge applies here too.
#            os.symlink(os.path.join("..", "..", our_video_file_path),
#                       upstream_video_file_path)
#            time.sleep(random.randint(2,7))
#        else:
#            print(f"Video file already present: '{video_file_path}'.")


if __name__ == '__main__':
  main()
