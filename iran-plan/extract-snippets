#!/usr/bin/env python3

"""extract-snippets: Extract snippets of video/audio, given timings.

Usage:

  ./extract-snippets -i INPUT_FILE

Read the entries in INPUT_FILE and write out numbered snippets to the
directory ./snippets (which must exist).

Here is an example input file consisting of three entries (indented by
two spaces here, but they wouldn't be indented in real life of course):

  * trump-bedminster-2021-07-audio.mp3
  
    00:24.00  1.00  I wanted to attack Iran
    01:25.00  1.00  he wanted to attack Iran
  
    (Imagine some random note here.)

  * 2017-02-28-address-joint-session-congress.mp4
  
    17:51.99  0.68  who support Iran's ballistic missile program

  # This is also a comment line, albeit of a different kind.

  * video/2017-09-19-address-united-nations-general-assembly.mp4
  
    17:31.00  0.70  in this room.  The Iranian government masks
    17:57.00  0.70  The longest-suffering victims of Iran’s leaders are
    18:05.00  0.70  Rather than use its resources to improve Iranian lives
    18:23.00  0.70  which rightly belongs to Iran’s people
    19:08.00  0.70  The Iran Deal was one of the worst
    19:31.00  0.70  join us in demanding that Iran’s government
    19:47.00  0.70  above all, Iran’s government
    20:00.00  0.70  good people of Iran want change
    20:08.00  0.70  that Iran’s
    20:45.00  0.70  will the Iranian people
    21:00.00  0.70  The Iranian regime’s support for terror
  
    NOTE: ERROR IN TRANSCRIPT: "the day will come when the [then the
    transcript has the word 'Iranian' here, but that word is not
    actually said] people will face a choice"

Spacing can be variable; only non-whitespace matters.  The format
works as it looks:

  - A line starting with "* " names a video or audio source file.

  - Whitespace then numbers is a timing line: start time, duration,
    then ignored text (the text is just there to help the human).

  - A line starting with "#" (maybe preceded by whitespace) is a
    comment and is ignored.

  - Any all-whitespace is ignored.

  - Any other kind of line is an error.

The output snippets are written into the directory ./snippets in the
order that they occur in the input, and each output file is given an
ordering prefix followed by a timing-and-duration component (with
colons converted to underscores, out of respect for our friends using
Microsoft Windows).  Thus, the above three example entries would
produce these output files:

  ./snippets/01-00_24.00-1.00-trump-bedminster-2021-07-audio.mp3
  ./snippets/02-01_25.00-1.00-trump-bedminster-2021-07-audio.mp3
  ./snippets/03-17_51.99-0.68-2017-02-28-address-joint-session-congress.mp4
  ./snippets/04-17_31.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/05-17_57.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/06-18_05.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/07-18_23.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/08-19_08.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/09-19_31.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/10-19_47.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/11-20_00.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/12-20_08.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/13-20_45.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/14-21_00.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
"""

import sys
import os
import re
import getopt
import subprocess
import math

SOURCE_RE = re.compile("^\*\s+([a-zA-Z0-9/-]+\.[a-zA-Z0-9]{3})\s*$")
TIMING_RE = re.compile("^\s+([0-9:.]+)\s+([0-9.]+)\s+.*$")
COMMENT_RE = re.compile("^\s*#.*$")
BLANK_LINE_RE = re.compile("^\s*$")

def get_schedule(infile):
    """Read INFILE (string -- a file name) and return a list of the form:
      [[source_name1, timing1, duration1],
       [source_name2, timing2, duration2],
       ...]
    Yes, a class would be more Pythonic.  But you know what's the most
    Pythonic thing of all?  Shipping."""
    fp = open(infile, "r")
    ret_list = []
    this_source = None
    this_elt = None

    for line in fp:
        line = line.rstrip()
        m = None
        # Python 3.10 introduced switch-case statements, but AFAICT
        # they only support matching static patterns, not regular
        # expression matches.  From an implementation and performance
        # perspective, I understand why this is, but from a source
        # code readability perspective, it's a pity.  Ah well.
        if (m := SOURCE_RE.match(line)) is not None:
            this_source = m.group(1)
        elif (m := TIMING_RE.match(line)) is not None:
            ret_list.append([this_source, m.group(1), m.group(2),])
        elif (m := COMMENT_RE.match(line)) is not None:
            pass
        elif (m := BLANK_LINE_RE.match(line)) is not None:
            pass
        else:
            sys.stderr.write(f"WARNING: Invalid line seen in input: '{line}'\n")
    return ret_list


def main():
    infile_name = None
    try:
        (opts, args) = getopt.getopt(sys.argv[1:], "i:h?",
                                     [ "input=",
                                       "help", 
                                       "usage",
                                     ])
    except getopt.GetoptError as err:
        sys.stderr.write(str(err))
        sys.stderr.write("\n")
        sys.exit(1)

    for opt, optarg in opts:
        if opt in ("-h", "-?", "--help", "--usage",):
            print(__doc__)
            sys.exit(0)
        elif opt in ("-i", "--input",):
            infile_name = optarg

    if infile_name is None:
        sys.stderr.write("ERROR: Need a file with sources and timings.\n")
        sys.stderr.write("       You probably forgot to use -i / --input.\n")
        sys.exit(1)
        
    schedule = get_schedule(infile_name)

    count = 0
    width = len(str(len(schedule)))
    for item in schedule:
        count += 1
        source, timing, duration, = item
        output_name = f"{str(count).zfill(width)}-{timing.replace(':', '_')}-{duration}-{os.path.basename(source)}"
        args = ["ffmpeg", 
                "-y",  # overwrite existing output files
                "-loglevel", "quiet",
                "-ss", timing, "-t", duration, 
                "-i", source,
                "-map", "0", "-c", "copy",
                os.path.join("snippets", output_name),]
        try:
            completed = subprocess.run(args,
                                       capture_output=True,
                                       shell=False,
                                       encoding="UTF-8",
                                       text=True,
                                       check=True)
            if len(completed.stderr) == 0:
                print(f"{output_name}")
            else:
                for line in completed.stderr.splitlines(keepends=True):
                    sys.stderr.write(f"ERROR: '{line}'")
        except subprocess.CalledProcessError as e:
            sys.stderr.write(f"ERROR: '{e}'\n")
            sys.exit(1)


if __name__ == '__main__':
  main()
