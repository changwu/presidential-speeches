#!/usr/bin/env python3

"""extract-snippets: Extract snippets of video/audio, given timings.

Usage:

  ./extract-snippets -i INPUT_FILE

Read the entries in INPUT_FILE and write out numbered snippets to the
directory ./snippets (which must exist).

Here is an example input file consisting of three entries (indented by
two spaces here, but they wouldn't be indented in real life of course):

  * trump-bedminster-2021-07-audio.mp3
  
    00:24.00  1.00  I wanted to attack Iran
    01:25.00  1.00  he wanted to attack Iran
  
    (Imagine some random note here.)

  * 2017-02-28-address-joint-session-congress.mp4
  
    17:51.99  0.68  who support Iran's ballistic missile program

  # This is also a comment line, albeit of a different kind.

  * video/2017-09-19-address-united-nations-general-assembly.mp4
  
    17:31.00  0.70  in this room.  The Iranian government masks
    17:57.00  0.70  The longest-suffering victims of Iran’s leaders are
    18:05.00  0.70  Rather than use its resources to improve Iranian lives
    18:23.00  0.70  which rightly belongs to Iran’s people
    19:08.00  0.70  The Iran Deal was one of the worst
    19:31.00  0.70  join us in demanding that Iran’s government
    19:47.00  0.70  above all, Iran’s government
    20:00.00  0.70  good people of Iran want change
    20:08.00  0.70  that Iran’s
    20:45.00  0.70  will the Iranian people
    21:00.00  0.70  The Iranian regime’s support for terror
  
    NOTE: ERROR IN TRANSCRIPT: "the day will come when the [then the
    transcript has the word 'Iranian' here, but that word is not
    actually said] people will face a choice"

Spacing can be variable; only non-whitespace matters.  The format
works as it looks:

  - A line starting with "* " names a video or audio source file.

  - Whitespace then numbers is a timing line: start time, duration,
    then ignored text (the text is just there to help the human).

  - A line starting with "#" (maybe preceded by whitespace) is a
    comment and is ignored.

  - Any all-whitespace is ignored.

  - Any other kind of line is an error.

The output snippets are written into the directory ./snippets in the
order that they occur in the input, and each output file is given an
ordering prefix followed by a timing-and-duration component (with
colons converted to underscores, out of respect for our friends using
Microsoft Windows).  Thus, the above three example entries would
produce these output files:

  ./snippets/01-00_24.00-1.00-trump-bedminster-2021-07-audio.mp3
  ./snippets/02-01_25.00-1.00-trump-bedminster-2021-07-audio.mp3
  ./snippets/03-17_51.99-0.68-2017-02-28-address-joint-session-congress.mp4
  ./snippets/04-17_31.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/05-17_57.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/06-18_05.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/07-18_23.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/08-19_08.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/09-19_31.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/10-19_47.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/11-20_00.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/12-20_08.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/13-20_45.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/14-21_00.00-0.70-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/15-bar-baz-qux-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/16-bar-baz-qux-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/17-bar-baz-qux-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/18-bar-baz-qux-2017-09-19-address-united-nations-general-assembly.mp4
  ./snippets/19-bar-baz-qux-2017-09-19-address-united-nations-general-assembly.mp4

"""

import sys
import os
import re
import getopt

def main():
    infile = None
    try:
        (opts, args) = getopt.getopt(sys.argv[1:], "i:h?",
                                     [ "input=",
                                       "help", 
                                       "usage",
                                     ])
    except getopt.GetoptError as err:
        sys.stderr.write(str(err))
        sys.stderr.write("\n")
        sys.exit(1)

    for opt, optarg in opts:
        if opt in ("-h", "-?", "--help", "--usage",):
            print(__doc__)
            sys.exit(0)
        elif opt in ("-i", "--input",):
            infile = open(optarg, "r")

    if infile is None:
        sys.stderr.write("ERROR: Need a file with sources and timings.\n")
        sys.stderr.write("       You probably forgot to use -i / --input.\n")
        sys.exit(1)
        
    source_re = re.compile("^\*\s+([a-zA-Z0-9/-]+)\.([a-zA-Z0-9]{3})\s*$")
    timing_re = re.compile("^\s+([0-9:.]+)\s+([0-9.]+)\s+.*$")
    comment_re = re.compile("^\s*#.*$")
    blank_line_re = re.compile("^\s*$")

    this_source = None
    this_timing = None
    this_duration = None
    for line in infile:
        line = line.rstrip()
        m = None
        # Python 3.10 introduced switch-case statements, but I think
        # they only support matching static patterns, not regular
        # expression matches.  From an implementation and performance
        # perspective, I understand why this is, but from a source
        # code readability perspective, it's a pity.  Ah well.
        if m := source_re.match(line) is not None:
            print(f"Matched source_re: '{line}'")
        elif m := timing_re.match(line) is not None:
            print(f"Matched timing_re: '{line}'")
        elif m := comment_re.match(line) is not None:
            print(f"Matched comment_re: '{line}'")
        elif m := blank_line_re.match(line) is not None:
            print(f"Matched blank_line_re: '{line}'")
        else:
            sys.stderr.write("WARNING: Invalid line seen in input:\n")
            sys.stderr.write(f"        '{line}'\n")

# rm -f tmp.mp4
# ffmpeg -ss 00:17:51.99 -t 0.68 -i video/2017-02-28-address-joint-session-congress.mp4 -map 0 -c copy tmp.mp4
# vlc tmp.mp4

if __name__ == '__main__':
  main()
